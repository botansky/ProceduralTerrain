<h1>Unreal Engine Procedural Terrain Generation Project</h1>
<em>Matan Botansky</em>
<br><br>

The broad idea of this project was to make an actor in UE4 that generates a tile of terrain based on a 3-layer noise calculation that mimics real-life terrain, utilising a mix of textures from the noise calculation to form its material, additionally involving a PRNG seed system that can regenerate the base noise maps for each terrain sample.
<br><br>

<b>Generating the Noise:</b>
<br>
	In order to generate the noise in this project, I effectively created a two-demensional array of FVectors, where each component of the vector holds a different noise calculation. To do this, I tried to build around the PerlinNoise2D function from the FMath library. However, due to the geometry created by raw Perlin noise, I decided to add some complexity by introducing octaves, as well as several other components. After playing around with different iterations of noise maps, I decided to have the first of the three vector components act as a primary for the height values of the mesh. The calculation for this component was done through simply taking a weighted average of the Perlin noise as generated by the seed value, and its absolute value, where the magnitude holds a much higher weight, resulting in a lot more natural looking topography. The other two components of the noisemap that are only used in the material are made of the same average with inverted weights and the same weighted average with the next seed. This procesws was repeated over each index combination, to provide noise values for each entry and acts as the backbone for the rest of the project.
<br><br>

<b>Creating and Updating the Terrain Mesh:</b>
<br>
	To create the mesh I used Unreal's ProceduralMeshComponent which is a dependency that has to be manually added in order to generate meshes of procedural geometry. Using asynchronous cooking, I was able to quite quickly render sections of mesh that could be updated by the editor when parameters are adjusted. This was done through several parameter arrays which I created from the first component of the noise data, most importantly including aspects such as the vertices and triangles of the mesh, as well as UV values such that the entire mesh could be covered by a single iteration of a texture. Naturally, the mesh is also created in a matter that can support collision and physics data. 
<br><br>
